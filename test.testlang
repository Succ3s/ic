#package main

#import fmt "std:fmt"


proc fib_a(const x: i32) { fib(x-1 + x-2) }
proc fib_b(const x: i32) where x <= 1 { 1 }
proc fib{fib_a, fib_b}
/*
fib(3)
proc fib3() { fib2() + fib1() }
proc fib2() { fib1() + fib0() }
proc fib1() { 1 }
proc fib0() { 1 }

*/

proc test_null_safety() {
	// null safety
	// - ptrs, anyptr       // they are pointers
	// - cstring            // cstring is a strong alias to *u8
	// - proc               // proc pointer
	// - slice, string, any // null if the inner pointer is null
	// - enum, union        // except @NoNull
	alias Foo struct {
		x: struct {
			y: struct { z: !*i32 },
		},
		b: bool,
	}
	var v = 1;
	var _1: Foo;                   // error
	var _2 = Foo { b = true     }; // error
	var _3 = Foo { x.y.z = null }; // error
	var _4 = Foo { x.y.z = v.&  }; // ok
}

proc test(x: X) bool {
	var a := 42;



	var d: union{int, bool} = true;
	var res = switch d {
		x: int if x == 1 { true  }
		x: bool          { x     }
		else             { false }
	};

	switch 1 {
		2, 3  { println("foo") }
		1..10 { println("aaa") }
	}

	if  x.(bool) != null             { println("aaa");   }
	for i in 0..1                    { println("%v", i); }
	if  true { println("aaa") } else { println("bbb");   }
}

#import t "core:type"
proc print_struct(s: any) {
	switch s.info {
		x: t.Named  {
			fmt.print("struct %s { ", x.name);
			var x = x.inner.(t.Struct); // union cast returns union{T}
			assert(x != null); // union{T} can be compared to null
			// x is T here
			print_fields(x);
			fmt.println("}");
		}
		x: t.Struct {
			fmt.print("struct { ");
			print_fields(x);
			fmt.println("}");
		}
	}
}

proc print_fields(s: t.Struct) {
	assert(s.fields >= 1);
	fmt.println("%s", s.names[0]);
	for i in 1..s.fields {
		fmt.println(", %s", s.names[i]);
	}
}



//
//
//	Trait-ish
//
//

type Arith(T: type) struct {
	add: proc(a, b: T) T;
	sub: proc(a, b: T) T;
	mul: proc(a, b: T) T;
	div: proc(a, b: T) T;
}



const i32Arith = Arith(i32) {
	add: proc(a, b: i32) i32 { a + b }
	sub: proc(a, b: i32) i32 { a - b }
	mul: proc(a, b: i32) i32 { a * b }
	div: proc(a, b: i32) i32 { a / b }
};

proc stuff(
	const arith: Arith(const T: type)),
	a, b: T
) T { arith.add(a, arith.mul(b, b)) }

proc test_trait_ish() { fmt.println("%s", stuff(i32Arith, 2.-, 7)) }

//
//
//	Alias & Type
//
//

proc test_types() {
	type  MyInt    int;
	alias IntAlias int;

	assert(typeid(MyInt) != typeid(int));
	assert(typeid(IntAlias) == typeid(int));
}
