(*

[] = optional
{} = one or more



TODO:
- make sure noNullType rule isn't wrong
- depency arrow
- tuples
- attrs
	- they will only exist in the ast, no way to query them at runtime
	- '@' ident '(' ? anything ? ')'
- expression precedence
- literals

*)

file = "package", ident ";", { item };

item = proc
     | typeDecl
     | decl
     | ( "import", ident, stringLit, ";" ) 
     ;


proc = "proc", ident, "(", [argDef, {",", argDef}] ")", [type], ";" | block;
argDef = ident ":" type;

decl = "const" | "var", ident, [ ":", type ], [ "=", expr ], ";";

typeDecl = "alias" | "type", ident, (typesWithoutBlock, ";") | (typesWithBlock, [";"]);






type = typesWithoutBlock | typesWithBlock;
typesWithoutBlock = ["!"], namedType
                  |        procType
                  |        arrayType
                  |        sliceType
                  |        ptrArrayType
                  |        ptrType
                  ;
namedType    = ident;
procType     = "proc", "(", [argDef, {",", argDef}], ")", [type];)
arrayType    = "[", expr, "]", type;
sliceType    = "[",       "]", type;
ptrArrayType = "[", "*",  "]", type;
ptrType      =      "*",       type;

typesWithBlock = struct
               | union
               | enum
               ;
struct   = "struct", "{", [ argDef, { ",", argDef } ],   "}";
union    = "union",  "{", [ type, { ",", type } ],       "}";
enum     = "enum",   "{", [ enumKey, { ",", enumKey } ], "}";
enumKey  = ident, [ "=", expr ];




label = ":", ident;
stmt = ";"
     |  decl
     |  ( [label], block         )
     |  ( [label], for           )
     |  ( [label], if            )
     |  ( [label], switch        )
     |  (             expr,  ";" )
     |  ( "return",   expr,  ";" )
     |  ( "defer",    expr,  ";" )
     |  ( "break",    ident, ";" ) (* label *)
     |  ( "continue", ident, ";" ) (* label *)
     ;


block = "{", { stmt }, "}";
if = "if", expr, block, { "else", "if", expr, block }, [ "else", block ];
for = "for", [ ident, [ ",", ident ], "in" ], expr, block;
switch = "switch", expr, "{", { switchCase, [ "if", expr ], block } "}";
switchCase = "else"
           | ( ident, ":", type )
           | ( expr, { ",", expr } )
           ;





(*

FIXME

9 (???) ::  number, ident, string, char, Tinit, group
8 (ltr) ::  ., ->, call, index, .*, .&, cast, init
8 (rtl) ::  -, not
7 (ltr) ::  *, /, %
6 (ltr) ::  +, -
5 (ltr) ::  ==, !=, >, <, >=, <=
4 (ltr) ::  and
3 (ltr) ::  or
2 (ltr) ::  orelse, .., ..<
1 (rtl) ::  =, +=, -=, *=, /=, %=

*)

expr = prefix | infix | postfix | literals;

prefix = "-"|"not", expr;
infix = ( expr, binop, expr )
      | ( expr, ".", ident  )
      ;
infixop = "+"   | "-"   | "*"  | "/"  | "%"
        | ">"   | "<"   | ">=" | "<=" | "==" | "!="
        | ".."  | "..<" | "orelse"
        | "and" | "or"
        ;

postfix = expr, postfixop;
postfixop =   ".*" | ".&"
          | ( ".", "(", ident | (":", type), ")"                          )
          | ( "as", ident | ("(", ":", type, ")")                         )
          | ( "(" expr, [ ",", expr ], ")"                                )
          | ( "[" expr "]"                                                )  
          | ( "if", expr, "else", expr                                    )
          | ( "switch", "{", switchExprBranch, ["," switchExprBranch] "}" )
          ;

switchExprBranch = switchCase, ['if' expr], '=>', expr;

literals = number | char | string | "(" expr ")"
	| procExpr
	| (ident, [initLit]              )
  | ( "(", ":", type, ")", initLit )
	;

procExpr = "proc", "(", [argDef, {",", argDef}], ")", [type], block;

initLit = "{", [ initField, { ",", initField } ], "}";
initField = ( "[", expr, "]" ) | expr, "=", expr;
