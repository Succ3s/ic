(*

[] = optional
{} = one or more



TODO:
- make sure noNullType rule isn't wrong
- depency arrow
- tuples
- attrs
	- they will only exist in the ast, no way to query them at runtime
	- '@' ident '(' ? anything ? ')'
- expression precedence
- literals

*)

file = "package", ident ";", { item };

item = proc
     | typeDecl
     | decl
     | ( "import", ident, stringLit, ";" ) 
     ;


proc = "proc", ident, "(", [argDef, {",", argDef}] ")", [type], ";" | block;
argDef = ident ":" type;

decl = "const" | "var", ident, [ ":", type ], [ "=", expr ], ";";

typeDecl = "alias" | "type", ident, (typesWithoutBlock, ";") | (typesWithBlock, [";"]);






type = typesWithoutBlock | typesWithBlock;
typesWithoutBlock = ["!"], namedType
                  |        procType
                  |        arrayType
                  |        sliceType
                  |        ptrArrayType
                  |        ptrType
                  ;
namedType    = ident;
procType     = "proc", "(", [argDef, {",", argDef}], ")", [type];)
arrayType    = "[", expr, "]", type;
sliceType    = "[",       "]", type;
ptrArrayType = "[", "*",  "]", type;
ptrType      =      "*",       type;

typesWithBlock = struct
               | union
               | enum
               ;
struct   = "struct", "{", [ argDef, { ",", argDef } ],   "}";
union    = "union",  "{", [ type, { ",", type } ],       "}";
enum     = "enum",   "{", [ enumKey, { ",", enumKey } ], "}";
enumKey  = ident, [ "=", expr ];






label = ident, ":";
stmt = ";"
     |  decl
     |  ( [label], block         )
     |  ( [label], for           )
     |  ( [label], if            )
     |  ( [label], switch        )
     |  (             expr,  ";" )
     |  ( "return",   expr,  ";" )
     |  ( "defer",    expr,  ";" )
     |  ( "break",    ident, ";" ) (* label *)
     |  ( "continue", ident, ";" ) (* label *)
     ;


block = "{", { stmt }, "}";
if = "if", expr, block, { "else", "if", expr, block }, [ "else", block ];
for = "for", [ ident, [ ",", ident ], "in" ], expr, block;
switch = "switch", expr, "{", { switchCase, [ "if", expr ], block } "}";
switchCase = "else"
           | ( ident, ":", type )
           | ( expr, { ",", expr } )
           ;





(*

9 (???) ::    number, ident, string, char, Tinit, group
8 (ltr) ::    ., ->, call, index, .-, .*, .&, .!, cast, init
7 (ltr) ::    *, /, %
6 (ltr) ::    +, -
5 (ltr) ::    ==, !=, >, <, >=, <=
4 (ltr) ::    and
3 (ltr) ::    or
2 (ltr) ::    orelse, .., ..<
1 (rtl) ::    =, +=, -=, *=, /=, %=

*)

expr = infix | postfix | literals;


infix = ( expr, binop, expr ) (* -TI *)
      | ( expr, ".", ident )  (* +TI *)
      ;
infixop = "+"   | "-"   | "*"  | "/"  | "%"
        | ">"   | "<"   | ">=" | "<=" | "==" | "!="
        | ".."  | "..<" | "orelse"
        | "and" | "or"
        | "->"
        ;

postfix = expr, postfixop;
postfixop = ".-" | ".*" | ".&" | ".!"
          | ( ".",   "(",  type,  ")"                                     )  (* -TI *)
          | ( "as", ["("], type, [")"]                                    )  (* -TI *)
          | ( "(" expr, [ ",", expr ], ")"                                )  (* +TI *)
          | ( "[" expr "]"                                                )  (* -TI *)
          | ( "{", [ initLit, { ",", initLit } ], "}"                     )  (* is TI, +TI *)
          | ( "if", expr, "else", expr                                    )  (* -TI *)
          | ( "switch", "{", switchExprBranch, ["," switchExprBranch] "}" )  (* -TI *)
          ;



initLit = ( "[", expr, "]" ) | expr, "=", expr;

switchExprBranch = switchCase, '=>', expr;

literals = number | char | string | "(" expr ")" (* -TI *)
	| ident                                      (* +TI *)
	| initTypes                                  (* +TI *)
	| exprWithBlock                              (* -TI *)
	| procExpr                                   (* -TI *)
	;

procExpr = "proc", "(", [argDef, {",", argDef}], ")", [type], block;

initTypes = sliceType | arrayType | ptrArrayType;
