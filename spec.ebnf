(*

[] = optional
{} = one or more



TODO:
- make sure noNullType rule isn't wrong
- depency arrow (should it really be an arrow?)
- (maybe) auto tuples (like go, and odin)
- (maybe) vector types (like glsl, and hlsl)
- attrs
	- they will only exist in the ast, no way to query them at runtime
	- '@' ident '(' ? anything ? ')'
- labels (break, continue)
- expression precedence
- literals
*)


ident = ? TODO ?;

file = package, { item };

package = "#package", ident;

item = import
	|  typeDef
	|  proc
	|  decl;

import = "#import", ident, stringLit;

typeDef = "type" | "alias", ident,
	( typesWithoutBlock, ";" ) | ( typesWithBlock [";"] );

proc = "proc", ident, "(", [argDef, {",", argDef}] ")", [type], ";" | blockWithDo;
argDef = ident ":" type;
(* argDef = ident, { ",", ident }, ":", type; *)

decl = "const" | "var", ident, [ ":", type ], [ "=", expr ], ";";




type = typesWithoutBlock | typesWithBlock;
typesWithoutBlock = namedType
	|               noNullType
	|               ptrType
	|               sliceType
	|               arrayType
	|               procType;
namedType = ident;
noNullType = "!",   ptrType
	|               namedType (* cstring, string, any, anyptr *)
    |               procType
    |               sliceType
    |               arrayType;
ptrType   = "*" type;
sliceType = "[" "]" type;
arrayType = "[" expr "]" type;
procType  = "proc", "(", [argDef, {",", argDef}], ")", [type];

typesWithBlock = struct
	|            union
	|            enum;
struct   = "struct", "{", [ argDef, { ",", argDef } ],   "}";
union    = "union",  "{", [ type, { ",", type } ],       "}";
enum     = "enum",   "{", [ enumKey, { ",", enumKey } ], "}";
enumKey  = ident, [ "=" expr ];




blockWithDo = ( "do", stmt ) | block;
block = "{", { stmt }, "}";





stmt = item
	|  for
	|  exprStmt
	|  "return", expr, ";"
	|  "break" ";"
	|  "continue" ";"
	;

for      = "for", [ ident, [ ",", ident ], "in" ], expr, blockWithDo;
exprStmt = exprWithBlock | ( exprWithoutBlock, ";" );




(*

10.??? :: number, ident, string, char, group
9.ltr  :: ., call, index, .-, .*, .&, .!, new, exprWithBlock
8.ltr  :: as
7.ltr  :: *, /, %
6.ltr  :: +, -
5.ltr  :: ==, !=
4.ltr  :: >, <, >=, <=
3.ltr  :: and
2.ltr  :: or
1.ltr  :: orelse, .., ..<
0.rtl  :: =, +=, -=, *=, /=, %=

*)



expr = exprWithoutBlock | exprWithBlock;

exprWithoutBlock = infix | postfix | literals;
infix = expr, "+",     expr
	|   expr, "-",     expr
	|   expr, "*",     expr
	|   expr, "/",     expr
	|   expr, "%",     expr

	|   expr, ">",      expr
	|   expr, "<",      expr
	|   expr, "==",     expr
	|   expr, "!=",     expr
	|   expr, ">=",     expr
	|   expr, "<=",     expr

	|   expr, "or",     expr
	|   expr, "and",    expr


	|   expr, ".",      expr

	|   expr, "..",     expr
	|   expr, "..<",    expr
	|   expr, "orelse", expr
	|   expr, "as",     type;
postfix = expr ".-"
	|     expr ".*"
	|     expr ".&"
	|     expr ".!"
	|     expr "(" [ expr { "," expr } ] ")"
	|     expr "[" expr "]";
literals = number | ident | char | string | "(" expr ")";

exprWithBlock = block
	|           if
	|           switch
	|           procExpr;
if = "if" expr, blockWithDo,
	{ "else", [ "if", expr ], blockWithDo };
switch = "switch", expr, "{", {switchBranch} "}";
switchBranch = switchCase, blockWithDo;
switchCase = "else"
	|        ident ":" type switchIf,
	|        expr, [switchIf], { ",", expr, [switchIf] };
switchIf = "if", expr;
procExpr = "proc", "(", [argDef, {",", argDef}], ")", [type], blockWithDo;
