(*

[] = optional
{} = one or more



TODO:
- make sure noNullType rule isn't wrong
- depency arrow (should it really be an arrow?)
- (maybe) auto tuples (like go, and odin)
- (maybe) vector types (like glsl, and hlsl)
- attrs
	- they will only exist in the ast, no way to query them at runtime
	- '@' ident '(' ? anything ? ')'
- labels (break, continue)
- expression precedence
- literals
*)


ident = ? TODO ?;

file = package, { item };

package = "#package", ident;

item = import
	|  typeDef
	|  proc
	|  decl;

import = "#import", ident, stringLit;

typeDef = "type" | "alias", ident,
	( typesWithoutBlock, ";" ) | ( typesWithBlock [";"] );

proc = "proc", ident, "(", [argDef, {",", argDef}] ")", [type], ";" | block;
argDef = ident ":" type;
(* argDef = ident, { ",", ident }, ":", type; *)

decl = "const" | "var", ident, [ ":", type ], [ "=", expr ], ";";




type = typesWithoutBlock | typesWithBlock;
typesWithoutBlock = namedType
	|               noNullType
	|               ptrType
	|               sliceType
	|               arrayType
	|               procType;
namedType = ident;
noNullType = "!",   ptrType
	|               namedType (* cstring, string, any, anyptr *)
    |               procType
    |               sliceType
    |               arrayType;
ptrType   = "*" type;
sliceType = "[" "]" type;
arrayType = "[" expr "]" type;
procType  = "proc", "(", [argDef, {",", argDef}], ")", [type];

typesWithBlock = struct
	|            union
	|            enum;
struct   = "struct", "{", [ argDef, { ",", argDef } ],   "}";
union    = "union",  "{", [ type, { ",", type } ],       "}";
enum     = "enum",   "{", [ enumKey, { ",", enumKey } ], "}";
enumKey  = ident, [ "=", expr ];


block = "{", { stmt }, [ expr ], "}";





stmt = item
	|  for
	|  exprStmt
	|  expr (* short for return stmt *)
	|  "return", expr, ";"
	|  "break",    ":", ident, [ expr ], ";"
	|  "continue", ":", ident, [ expr ], ";"
	;

for      = "for", [ ident, [ ",", ident ], "in" ], expr, block;
exprStmt = exprWithBlock | ( exprWithoutBlock, ";" );




(*

11 (???) ::    group
10 (???) ::    number, ident, string, char, literal
9  (ltr) ::    ., call, index, .-, .*, .&, .!, exprWithBlock, cast
7  (ltr) ::    *, /, %
6  (ltr) ::    +, -
5  (ltr) ::    ==, !=
4  (ltr) ::    >, <, >=, <=
3  (ltr) ::    and
2  (ltr) ::    or
1  (ltr) ::    orelse, .., ..<
0  (rtl) ::    =, +=, -=, *=, /=, %=

*)

expr = exprWithoutBlock | exprWithBlock;

exprWithoutBlock = infix | postfix | literals;
infix = expr, "+",     expr
	|   expr, "-",     expr
	|   expr, "*",     expr
	|   expr, "/",     expr
	|   expr, "%",     expr

	|   expr, ">",      expr
	|   expr, "<",      expr
	|   expr, "==",     expr
	|   expr, "!=",     expr
	|   expr, ">=",     expr
	|   expr, "<=",     expr

	|   expr, "or",     expr
	|   expr, "and",    expr


	|   expr, ".", ident

	|   expr, "..",     expr
	|   expr, "..<",    expr
	|   expr, "orelse", expr
	|   expr, "as",     type;
postfix = ( expr, ".-"                              )
	|     ( expr, ".*"                              )
	|     ( expr, ".&"                              )
	|     ( expr, ".!"                              )
	|     ( expr, ".", "(", type, ")"               )
	|     ( expr, "(", [ expr, { ",", expr } ], ")" )
	|     ( expr, "[", expr, "]"                    );
literals = number | char | string | "(" expr ")" | ident
	|      ( [ ident, ':' ],  exprWithBlock );
(* no lookahead - ident, [ ":", exprWithBlock ] *)



exprWithBlock = block
	|           if
	|           switch
	|           procExpr;
if = "if" expr, block,
	{ "else", "if", expr, block },
	[ "else", block ];
switch = "switch", expr, "{", {switchBranch} "}";
switchBranch = switchCase, block;
switchCase = "else"
	|        ident ":" type switchIf,
	|        expr, [switchIf], { ",", expr, [switchIf] };
switchIf = "if", expr;
procExpr = "proc", "(", [argDef, {",", argDef}], ")", [type], block;
