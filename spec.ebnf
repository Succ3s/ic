(*

[] = optional
{} = one or more



TODO:
- make sure noNullType rule isn't wrong
- depency arrow (should it really be an arrow?)
- (maybe) auto tuples (like go, and odin)
- (maybe) vector types (like glsl, and hlsl)
- attrs
	- they will only exist in the ast, no way to query them at runtime
	- '@' ident '(' ? anything ? ')'
- labels (break, continue)
- expression precedence
- literals
*)


ident = ? TODO ?;

file = package, { item };

package = "#package", ident;

item = import
	|  proc
	|  typeDecl
	|  decl;

import = "#import", ident, stringLit;

proc = "proc", ident, "(", [argDef, {",", argDef}] ")", [type], ";" | block;
argDef = ident ":" type;

decl = "const" | "var", ident, [ ":", type ], [ "=", expr ], ";";

typeDecl = "alias" | "type", ident, (typesWithoutBlock, ";") | (typesWithBlock, [";"]);

type = typesWithoutBlock | typesWithBlock;
typesWithoutBlock = ["!"], namedType
	|                      procType
	|                      ptrType
	|                      sliceType
	|                      arrayType
	|                      ptrArrayType;
namedType    = ident;
procType     = "*", "proc", "(", [argDef, {",", argDef}], ")", [type];)
ptrType      = "*", type;
sliceType    = "[", "]", type;
arrayType    = "[", expr, "]", type;
ptrArrayType = "[", "*", "]", type;

typesWithBlock = struct
	|            union
	|            enum;
struct   = "struct", "{", [ argDef, { ",", argDef } ],   "}";
union    = "union",  "{", [ type, { ",", type } ],       "}";
enum     = "enum",   "{", [ enumKey, { ",", enumKey } ], "}";
enumKey  = ident, [ "=", expr ];


block = "{", { stmt }, [ expr ], "}";





stmt = ";"
	|  item
	|  for
	|  exprStmt
	|  ( "break",    ":", ident, [ expr ], ";" )
	|  ( "continue", ":", ident, [ expr ], ";" )
	|  ( "defer", exprStmt                     );

for      = "for", [ ident, [ ",", ident ], "in" ], expr, block;
exprStmt = exprWithBlock | ( exprWithoutBlock, ";" );




(*

11 (???) ::    group
10 (???) ::    number, ident, string, char, literal
9  (ltr) ::    ., call, index, .-, .*, .&, .!, exprWithBlock, cast, init
7  (ltr) ::    *, /, %
6  (ltr) ::    +, -
5  (ltr) ::    ==, !=
4  (ltr) ::    >, <, >=, <=
3  (ltr) ::    and
2  (ltr) ::    or
1  (ltr) ::    orelse, .., ..<
0  (rtl) ::    =, +=, -=, *=, /=, %=

*)

expr = exprWithoutBlock | exprWithBlock;

exprWithoutBlock = infix | postfix | literals;
infix = expr, "+",     expr                                  (* flags &= ~EXPR_TYPE_INIT *)
	|   expr, "-",     expr                                  (* flags &= ~EXPR_TYPE_INIT *)
	|   expr, "*",     expr                                  (* flags &= ~EXPR_TYPE_INIT *)
	|   expr, "/",     expr                                  (* flags &= ~EXPR_TYPE_INIT *)
	|   expr, "%",     expr                                  (* flags &= ~EXPR_TYPE_INIT *)

	|   expr, ">",      expr                                 (* flags &= ~EXPR_TYPE_INIT *)
	|   expr, "<",      expr                                 (* flags &= ~EXPR_TYPE_INIT *)
	|   expr, "==",     expr                                 (* flags &= ~EXPR_TYPE_INIT *)
	|   expr, "!=",     expr                                 (* flags &= ~EXPR_TYPE_INIT *)
	|   expr, ">=",     expr                                 (* flags &= ~EXPR_TYPE_INIT *)
	|   expr, "<=",     expr                                 (* flags &= ~EXPR_TYPE_INIT *)

	|   expr, "or",     expr                                 (* flags &= ~EXPR_TYPE_INIT *)
	|   expr, "and",    expr                                 (* flags &= ~EXPR_TYPE_INIT *)


	|   expr, ".", ident                                     (* flags |= EXPR_TYPE_INIT *)

	|   expr, "..",     expr                                 (* flags &= ~EXPR_TYPE_INIT *)
	|   expr, "..<",    expr                                 (* flags &= ~EXPR_TYPE_INIT *)
	|   expr, "orelse", expr                                 (* flags &= ~EXPR_TYPE_INIT *)
	|   expr, "as",     type;                                (* flags &= ~EXPR_TYPE_INIT *)
postfix = ( expr, ".-"                                    )  (* flags &= ~EXPR_TYPE_INIT *)
	|     ( expr, ".*"                                    )  (* flags &= ~EXPR_TYPE_INIT *)
	|     ( expr, ".&"                                    )  (* flags &= ~EXPR_TYPE_INIT *)
	|     ( expr, ".!"                                    )  (* flags &= ~EXPR_TYPE_INIT *)
	|     ( expr, ".", "(", type, ")"                     )  (* flags &= ~EXPR_TYPE_INIT *)
	|     ( expr, "(", [ expr, { ",", expr } ], ")"       )  (* flags |= EXPR_TYPE_INIT *)
	|     ( expr, "[", expr, "]"                          )  (* flags &= ~EXPR_TYPE_INIT *)
	|     ( expr, "{", [ initLit, { ",", initLit } ], "}" ); (* only if flags & EXPR_TYPE_INIT, flags &= ~EXPR_TYPE_INIT *)
initLit = ( "[", expr, "]" ) | expr, "=", expr;

literals = number | char | string | "(" expr ")"             (* flags &= ~EXPR_TYPE_INIT *)
	| ident                                                  (* flags |= EXPR_TYPE_INIT *)
	| initTypes                                              (* flags |= EXPR_TYPE_INIT *)
	| exprWithBlock;                                         (* flags &= ~EXPR_TYPE_INIT *)

initTypes = sliceType | arrayType | ptrArrayType;


exprWithBlock = [ ident, ':' ], block
	|                           if
	|                           switch
	|                           procExpr;
if = "if" expr, block,
	{ "else", "if", expr, block },
	[ "else", block ];
switch = "switch", expr, "{", {switchBranch} "}";
switchBranch = switchCase, block;
switchCase = "else"
	|        ident ":" type switchIf,
	|        expr, [switchIf], { ",", expr, [switchIf] };
switchIf = "if", expr;
procExpr = "proc", "(", [argDef, {",", argDef}], ")", [type], block;
