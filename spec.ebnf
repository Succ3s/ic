(*

[] = optional
{} = one or more



TODO:
- make sure noNullType rule isn't wrong
- depency arrow (should it really be an arrow?)
- (maybe) auto tuples (like go, and odin)
- (maybe) vector types (like glsl, and hlsl)
- attrs
	- they will only exist in the ast, no way to query them at runtime
	- '@' ident '(' ? anything ? ')'
- labels (break, continue)
- expression precedence
- literals
*)


ident = ? TODO ?;

file = package, { item };

package = "#package", ident;

item = import
	|  proc
	|  decl;

import = "#import", ident, stringLit;

proc = "proc", ident, "(", [argDef, {",", argDef}] ")", [type], ";" | block;
argDef = ident ":" type;

decl = "const" | "var", ident, [ ":", type ], [ "=", expr ], ";";


type = typesWithoutBlock | typesWithBlock;
typesWithoutBlock = ["!"], namedType (* only if flags & EXPR_SUBSET *)
	|                      procType
	|                      ptrType
	|                      sliceType
	|                      arrayType
	|                      ptrArrayType;
namedType    = ident;                                                  (* flags |= TYPE_INIT *)
procType     = "*", "proc", "(", [argDef, {",", argDef}], ")", [type]; (* flags ^= TYPE_INIT *)
ptrType      = "*", type;                                              (* flags ^= TYPE_INIT *)
sliceType    = "[", "]", type;                                         (* flags |= TYPE_INIT *)
arrayType    = "[", expr, "]", type;                                   (* flags |= TYPE_INIT *)
ptrArrayType = "[", "*", "]", type;                                    (* flags |= TYPE_INIT *)

typesWithBlock = struct
	|            union
	|            enum;
struct   = "struct", "{", [ argDef, { ",", argDef } ],   "}"; (* flags |= TYPE_INIT *)
union    = "union",  "{", [ type, { ",", type } ],       "}"; (* flags ^= TYPE_INIT *)
enum     = "enum",   "{", [ enumKey, { ",", enumKey } ], "}"; (* flags ^= TYPE_INIT *)
enumKey  = ident, [ "=", expr ];


block = "{", { stmt }, [ expr ], "}";





stmt = ";"
	|  item
	|  for
	|  exprStmt
	|  ( "break",    ":", ident, [ expr ], ";" )
	|  ( "continue", ":", ident, [ expr ], ";" )
	|  ( "defer", exprStmt                     );

for      = "for", [ ident, [ ",", ident ], "in" ], expr, block;
exprStmt = exprWithBlock | ( exprWithoutBlock, ";" );




(*

11 (???) ::    group
10 (???) ::    number, ident, string, char, literal
9  (ltr) ::    ., call, index, .-, .*, .&, .!, exprWithBlock, cast
7  (ltr) ::    *, /, %
6  (ltr) ::    +, -
5  (ltr) ::    ==, !=
4  (ltr) ::    >, <, >=, <=
3  (ltr) ::    and
2  (ltr) ::    or
1  (ltr) ::    orelse, .., ..<
0  (rtl) ::    =, +=, -=, *=, /=, %=

*)

expr = exprWithoutBlock | exprWithBlock;

exprWithoutBlock = infix | postfix | literals;
infix = expr, "+",     expr
	|   expr, "-",     expr
	|   expr, "*",     expr
	|   expr, "/",     expr
	|   expr, "%",     expr

	|   expr, ">",      expr
	|   expr, "<",      expr
	|   expr, "==",     expr
	|   expr, "!=",     expr
	|   expr, ">=",     expr
	|   expr, "<=",     expr

	|   expr, "or",     expr
	|   expr, "and",    expr


	|   expr, ".", ident (* flags |= WAS_TYPE *)

	|   expr, "..",     expr
	|   expr, "..<",    expr
	|   expr, "orelse", expr
	|   expr, "as",     type;
postfix = ( expr, ".-"                                   )
	|     ( expr, ".*"                                   )
	|     ( expr, ".&"                                   )
	|     ( expr, ".!"                                   )
	|     ( expr, ".", "(", type, ")"                    )
	|     ( expr, "(", [ expr, { ",", expr } ], ")"      )  (* flags |= WAS_TYPE *)
	|     ( expr, "[", expr, "]"                         )
	|     ( expr, "{", [ initLit, { "," initLit } ], "}" ); (* only if flags & (WAS_TYPE | TYPE_INIT) *)
initLit = ( "[", expr, "]" ) | expr, "=", expr;

literals = number | char | string | "(" expr ")"
	| ident (* flags |= WAS_TYPE *)
	| type  (* flags |= WAS_TYPE *)
	| ( "#type" type )
	| exprWithBlock;

exprWithBlock = [ ident, ':' ], block
	|                           if
	|                           switch
	|                           procExpr;
if = "if" expr, block,
	{ "else", "if", expr, block },
	[ "else", block ];
switch = "switch", expr, "{", {switchBranch} "}";
switchBranch = switchCase, block;
switchCase = "else"
	|        ident ":" type switchIf,
	|        expr, [switchIf], { ",", expr, [switchIf] };
switchIf = "if", expr;
procExpr = "proc", "(", [argDef, {",", argDef}], ")", [type], block;
